---
subcategory: "Recovery Services"
layout: "azurerm"
page_title: "Azure Resource Manager: azurerm_site_recovery_replicated_vm"
description: |-
    Manages a VM protected with Azure Site Recovery on Azure.
---


<!-- Please do not edit this file, it is generated. -->
# azurerm_site_recovery_replicated_vm

Manages a VM replicated using Azure Site Recovery (Azure to Azure only). A replicated VM keeps a copiously updated image of the VM in another region in order to be able to start the VM in that region in case of a disaster.

## Example Usage

```python
import constructs as constructs
import cdktf as cdktf
# Provider bindings are generated by running cdktf get.
# See https://cdk.tf/provider-generation for more details.
import ...gen.providers.azurerm as azurerm
class MyConvertedCode(cdktf.TerraformStack):
    def __init__(self, scope, name):
        super().__init__(scope, name)
        azurerm_resource_group_primary = azurerm.resource_group.ResourceGroup(self, "primary",
            location="West US",
            name="tfex-replicated-vm-primary"
        )
        azurerm_resource_group_secondary =
        azurerm.resource_group.ResourceGroup(self, "secondary",
            location="East US",
            name="tfex-replicated-vm-secondary"
        )
        azurerm_storage_account_primary =
        azurerm.storage_account.StorageAccount(self, "primary_2",
            account_replication_type="LRS",
            account_tier="Standard",
            location=cdktf.Token.as_string(azurerm_resource_group_primary.location),
            name="primaryrecoverycache",
            resource_group_name=cdktf.Token.as_string(azurerm_resource_group_primary.name)
        )
        # This allows the Terraform resource name to match the original name. You can remove the call if you don't need them to match.
        azurerm_storage_account_primary.override_logical_id("primary")
        azurerm_virtual_network_primary =
        azurerm.virtual_network.VirtualNetwork(self, "primary_3",
            address_space=["192.168.1.0/24"],
            location=cdktf.Token.as_string(azurerm_resource_group_primary.location),
            name="network1",
            resource_group_name=cdktf.Token.as_string(azurerm_resource_group_primary.name)
        )
        # This allows the Terraform resource name to match the original name. You can remove the call if you don't need them to match.
        azurerm_virtual_network_primary.override_logical_id("primary")
        azurerm_virtual_network_secondary =
        azurerm.virtual_network.VirtualNetwork(self, "secondary_4",
            address_space=["192.168.2.0/24"],
            location=cdktf.Token.as_string(azurerm_resource_group_secondary.location),
            name="network2",
            resource_group_name=cdktf.Token.as_string(azurerm_resource_group_secondary.name)
        )
        # This allows the Terraform resource name to match the original name. You can remove the call if you don't need them to match.
        azurerm_virtual_network_secondary.override_logical_id("secondary")
        azurerm_public_ip_primary = azurerm.public_ip.PublicIp(self, "primary_5",
            allocation_method="Static",
            location=cdktf.Token.as_string(azurerm_resource_group_primary.location),
            name="vm-public-ip-primary",
            resource_group_name=cdktf.Token.as_string(azurerm_resource_group_primary.name),
            sku="Basic"
        )
        # This allows the Terraform resource name to match the original name. You can remove the call if you don't need them to match.
        azurerm_public_ip_primary.override_logical_id("primary")
        azurerm_public_ip_secondary = azurerm.public_ip.PublicIp(self, "secondary_6",
            allocation_method="Static",
            location=cdktf.Token.as_string(azurerm_resource_group_secondary.location),
            name="vm-public-ip-secondary",
            resource_group_name=cdktf.Token.as_string(azurerm_resource_group_secondary.name),
            sku="Basic"
        )
        # This allows the Terraform resource name to match the original name. You can remove the call if you don't need them to match.
        azurerm_public_ip_secondary.override_logical_id("secondary")
        azurerm_recovery_services_vault_vault =
        azurerm.recovery_services_vault.RecoveryServicesVault(self, "vault",
            location=cdktf.Token.as_string(azurerm_resource_group_secondary.location),
            name="example-recovery-vault",
            resource_group_name=cdktf.Token.as_string(azurerm_resource_group_secondary.name),
            sku="Standard"
        )
        azurerm_site_recovery_fabric_primary =
        azurerm.site_recovery_fabric.SiteRecoveryFabric(self, "primary_8",
            location=cdktf.Token.as_string(azurerm_resource_group_primary.location),
            name="primary-fabric",
            recovery_vault_name=cdktf.Token.as_string(azurerm_recovery_services_vault_vault.name),
            resource_group_name=cdktf.Token.as_string(azurerm_resource_group_secondary.name)
        )
        # This allows the Terraform resource name to match the original name. You can remove the call if you don't need them to match.
        azurerm_site_recovery_fabric_primary.override_logical_id("primary")
        azurerm_site_recovery_fabric_secondary =
        azurerm.site_recovery_fabric.SiteRecoveryFabric(self, "secondary_9",
            location=cdktf.Token.as_string(azurerm_resource_group_secondary.location),
            name="secondary-fabric",
            recovery_vault_name=cdktf.Token.as_string(azurerm_recovery_services_vault_vault.name),
            resource_group_name=cdktf.Token.as_string(azurerm_resource_group_secondary.name)
        )
        # This allows the Terraform resource name to match the original name. You can remove the call if you don't need them to match.
        azurerm_site_recovery_fabric_secondary.override_logical_id("secondary")
        azurerm_site_recovery_network_mapping_network_mapping =
        azurerm.site_recovery_network_mapping.SiteRecoveryNetworkMapping(self, "network-mapping",
            name="network-mapping",
            recovery_vault_name=cdktf.Token.as_string(azurerm_recovery_services_vault_vault.name),
            resource_group_name=cdktf.Token.as_string(azurerm_resource_group_secondary.name),
            source_network_id=cdktf.Token.as_string(azurerm_virtual_network_primary.id),
            source_recovery_fabric_name=cdktf.Token.as_string(azurerm_site_recovery_fabric_primary.name),
            target_network_id=cdktf.Token.as_string(azurerm_virtual_network_secondary.id),
            target_recovery_fabric_name=cdktf.Token.as_string(azurerm_site_recovery_fabric_secondary.name)
        )
        azurerm_site_recovery_protection_container_primary =
        azurerm.site_recovery_protection_container.SiteRecoveryProtectionContainer(self, "primary_11",
            name="primary-protection-container",
            recovery_fabric_name=cdktf.Token.as_string(azurerm_site_recovery_fabric_primary.name),
            recovery_vault_name=cdktf.Token.as_string(azurerm_recovery_services_vault_vault.name),
            resource_group_name=cdktf.Token.as_string(azurerm_resource_group_secondary.name)
        )
        # This allows the Terraform resource name to match the original name. You can remove the call if you don't need them to match.
        azurerm_site_recovery_protection_container_primary.override_logical_id("primary")
        azurerm_site_recovery_protection_container_secondary =
        azurerm.site_recovery_protection_container.SiteRecoveryProtectionContainer(self, "secondary_12",
            name="secondary-protection-container",
            recovery_fabric_name=cdktf.Token.as_string(azurerm_site_recovery_fabric_secondary.name),
            recovery_vault_name=cdktf.Token.as_string(azurerm_recovery_services_vault_vault.name),
            resource_group_name=cdktf.Token.as_string(azurerm_resource_group_secondary.name)
        )
        # This allows the Terraform resource name to match the original name. You can remove the call if you don't need them to match.
        azurerm_site_recovery_protection_container_secondary.override_logical_id("secondary")
        azurerm_site_recovery_replication_policy_policy =
        azurerm.site_recovery_replication_policy.SiteRecoveryReplicationPolicy(self, "policy",
            application_consistent_snapshot_frequency_in_minutes=cdktf.Token.as_number(
                cdktf.Op.mul(4, 60)),
            name="policy",
            recovery_point_retention_in_minutes=cdktf.Token.as_number(
                cdktf.Op.mul(24, 60)),
            recovery_vault_name=cdktf.Token.as_string(azurerm_recovery_services_vault_vault.name),
            resource_group_name=cdktf.Token.as_string(azurerm_resource_group_secondary.name)
        )
        azurerm_subnet_primary = azurerm.subnet.Subnet(self, "primary_14",
            address_prefixes=["192.168.1.0/24"],
            name="network1-subnet",
            resource_group_name=cdktf.Token.as_string(azurerm_resource_group_primary.name),
            virtual_network_name=cdktf.Token.as_string(azurerm_virtual_network_primary.name)
        )
        # This allows the Terraform resource name to match the original name. You can remove the call if you don't need them to match.
        azurerm_subnet_primary.override_logical_id("primary")
        azurerm_subnet_secondary = azurerm.subnet.Subnet(self, "secondary_15",
            address_prefixes=["192.168.2.0/24"],
            name="network2-subnet",
            resource_group_name=cdktf.Token.as_string(azurerm_resource_group_secondary.name),
            virtual_network_name=cdktf.Token.as_string(azurerm_virtual_network_secondary.name)
        )
        # This allows the Terraform resource name to match the original name. You can remove the call if you don't need them to match.
        azurerm_subnet_secondary.override_logical_id("secondary")
        azurerm_network_interface_vm =
        azurerm.network_interface.NetworkInterface(self, "vm",
            ip_configuration=[NetworkInterfaceIpConfiguration(
                name="vm",
                private_ip_address_allocation="Dynamic",
                public_ip_address_id=cdktf.Token.as_string(azurerm_public_ip_primary.id),
                subnet_id=cdktf.Token.as_string(azurerm_subnet_primary.id)
            )
            ],
            location=cdktf.Token.as_string(azurerm_resource_group_primary.location),
            name="vm-nic",
            resource_group_name=cdktf.Token.as_string(azurerm_resource_group_primary.name)
        )
        azurerm_site_recovery_protection_container_mapping_container_mapping =
        azurerm.site_recovery_protection_container_mapping.SiteRecoveryProtectionContainerMapping(self, "container-mapping",
            name="container-mapping",
            recovery_fabric_name=cdktf.Token.as_string(azurerm_site_recovery_fabric_primary.name),
            recovery_replication_policy_id=cdktf.Token.as_string(azurerm_site_recovery_replication_policy_policy.id),
            recovery_source_protection_container_name=cdktf.Token.as_string(azurerm_site_recovery_protection_container_primary.name),
            recovery_target_protection_container_id=cdktf.Token.as_string(azurerm_site_recovery_protection_container_secondary.id),
            recovery_vault_name=cdktf.Token.as_string(azurerm_recovery_services_vault_vault.name),
            resource_group_name=cdktf.Token.as_string(azurerm_resource_group_secondary.name)
        )
        azurerm_virtual_machine_vm = azurerm.virtual_machine.VirtualMachine(self, "vm_18",
            location=cdktf.Token.as_string(azurerm_resource_group_primary.location),
            name="vm",
            network_interface_ids=[
                cdktf.Token.as_string(azurerm_network_interface_vm.id)
            ],
            os_profile=VirtualMachineOsProfile(
                admin_password="test-pwd-123",
                admin_username="test-admin-123",
                computer_name="vm"
            ),
            os_profile_linux_config=VirtualMachineOsProfileLinuxConfig(
                disable_password_authentication=False
            ),
            resource_group_name=cdktf.Token.as_string(azurerm_resource_group_primary.name),
            storage_image_reference=VirtualMachineStorageImageReference(
                offer="CentOS",
                publisher="OpenLogic",
                sku="7.5",
                version="latest"
            ),
            storage_os_disk=VirtualMachineStorageOsDisk(
                caching="ReadWrite",
                create_option="FromImage",
                managed_disk_type="Premium_LRS",
                name="vm-os-disk",
                os_type="Linux"
            ),
            vm_size="Standard_B1s"
        )
        # This allows the Terraform resource name to match the original name. You can remove the call if you don't need them to match.
        azurerm_virtual_machine_vm.override_logical_id("vm")
        azurerm.site_recovery_replicated_vm.SiteRecoveryReplicatedVm(self, "vm-replication",
            depends_on=[azurerm_site_recovery_protection_container_mapping_container_mapping, azurerm_site_recovery_network_mapping_network_mapping
            ],
            managed_disk=[SiteRecoveryReplicatedVmManagedDisk(
                disk_id=cdktf.Token.as_string(
                    cdktf.property_access(azurerm_virtual_machine_vm.storage_os_disk, ["0", "managed_disk_id"
                    ])),
                staging_storage_account_id=cdktf.Token.as_string(azurerm_storage_account_primary.id),
                target_disk_type="Premium_LRS",
                target_replica_disk_type="Premium_LRS",
                target_resource_group_id=cdktf.Token.as_string(azurerm_resource_group_secondary.id)
            )
            ],
            name="vm-replication",
            network_interface=[SiteRecoveryReplicatedVmNetworkInterface(
                recovery_public_ip_address_id=cdktf.Token.as_string(azurerm_public_ip_secondary.id),
                source_network_interface_id=cdktf.Token.as_string(azurerm_network_interface_vm.id),
                target_subnet_name=cdktf.Token.as_string(azurerm_subnet_secondary.name)
            )
            ],
            recovery_replication_policy_id=cdktf.Token.as_string(azurerm_site_recovery_replication_policy_policy.id),
            recovery_vault_name=cdktf.Token.as_string(azurerm_recovery_services_vault_vault.name),
            resource_group_name=cdktf.Token.as_string(azurerm_resource_group_secondary.name),
            source_recovery_fabric_name=cdktf.Token.as_string(azurerm_site_recovery_fabric_primary.name),
            source_recovery_protection_container_name=cdktf.Token.as_string(azurerm_site_recovery_protection_container_primary.name),
            source_vm_id=cdktf.Token.as_string(azurerm_virtual_machine_vm.id),
            target_recovery_fabric_id=cdktf.Token.as_string(azurerm_site_recovery_fabric_secondary.id),
            target_recovery_protection_container_id=cdktf.Token.as_string(azurerm_site_recovery_protection_container_secondary.id),
            target_resource_group_id=cdktf.Token.as_string(azurerm_resource_group_secondary.id)
        )
```

## Argument Reference

The following arguments are supported:

* `name` - (Required) The name of the replication for the replicated VM. Changing this forces a new resource to be created.

* `resource_group_name` - (Required) Name of the resource group where the vault that should be updated is located. Changing this forces a new resource to be created.

* `recovery_vault_name` - (Required) The name of the vault that should be updated. Changing this forces a new resource to be created.

* `recovery_replication_policy_id` - (Required) Id of the policy to use for this replicated vm. Changing this forces a new resource to be created.

* `source_recovery_fabric_name` - (Required) Name of fabric that should contain this replication. Changing this forces a new resource to be created.

* `source_vm_id` - (Required) Id of the VM to replicate Changing this forces a new resource to be created.

* `source_recovery_protection_container_name` - (Required) Name of the protection container to use. Changing this forces a new resource to be created.

* `target_resource_group_id` - (Required) Id of resource group where the VM should be created when a failover is done. Changing this forces a new resource to be created.

* `target_recovery_fabric_id` - (Required) Id of fabric where the VM replication should be handled when a failover is done. Changing this forces a new resource to be created.

* `target_recovery_protection_container_id` - (Required) Id of protection container where the VM replication should be created when a failover is done. Changing this forces a new resource to be created.

* `target_availability_set_id` - (Optional) Id of availability set that the new VM should belong to when a failover is done.

* `target_zone` - (Optional) Specifies the Availability Zone where the Failover VM should exist. Changing this forces a new resource to be created.

* `managed_disk` - (Optional) One or more `managed_disk` block as defined below. Changing this forces a new resource to be created.

* `unmanaged_disk` - (Optional) One or more `unmanaged_disk` block. Changing this forces a new resource to be created.
 
* `target_edge_zone` - (Optional) Specifies the Edge Zone within the Azure Region where this Managed Kubernetes Cluster should exist. Changing this forces a new resource to be created.

* `target_proximity_placement_group_id` - (Optional) Id of Proximity Placement Group the new VM should belong to when a failover is done.

* `target_boot_diagnostic_storage_account_id` - (Optional) Id of the storage account which the new VM should used for boot diagnostic when a failover is done.

* `target_capacity_reservation_group_id` - (Optional) Id of the Capacity reservation group where the new VM should belong to when a failover is done.

* `target_virtual_machine_scale_set_id` - (Optional) Id of the Virtual Machine Scale Set which the new Vm should belong to when a failover is done.

* `target_network_id` - (Optional) Network to use when a failover is done (recommended to set if any network_interface is configured for failover).

* `test_network_id` - (Optional) Network to use when a test failover is done.

* `network_interface` - (Optional) One or more `network_interface` block as defined below.
* 
* `multi_vm_group_name` - (Optional) Name of group in which all machines will replicate together and have shared crash consistent and app-consistent recovery points when failed over.

---

A `managed_disk` block supports the following:

* `disk_id` - (Required) Id of disk that should be replicated. Changing this forces a new resource to be created.

* `staging_storage_account_id` - (Required) Storage account that should be used for caching. Changing this forces a new resource to be created.

* `target_resource_group_id` - (Required) Resource group disk should belong to when a failover is done. Changing this forces a new resource to be created.

* `target_disk_type` - (Required) What type should the disk be when a failover is done. Possible values are `Standard_LRS`, `Premium_LRS`, `StandardSSD_LRS` and `UltraSSD_LRS`. Changing this forces a new resource to be created.

* `target_replica_disk_type` - (Required) What type should the disk be that holds the replication data. Possible values are `Standard_LRS`, `Premium_LRS`, `StandardSSD_LRS` and `UltraSSD_LRS`. Changing this forces a new resource to be created.

* `target_disk_encryption_set_id` - (Optional) The Disk Encryption Set that the Managed Disk will be associated with. Changing this forces a new resource to be created.

-> **NOTE:** Creating replicated vm with `target_disk_encryption_set_id` wil take more time (up to 5 hours), please extend the `timeout` for `create`. 

* `target_disk_encryption` - (Optional) A `target_disk_encryption` block as defined below.

---

A `unmanaged_disk` block supports the following:

* `disk_uri` - (Required) Id of disk that should be replicated.

* `staging_storage_account_id` - (Required) Storage account that should be used for caching.

* `target_storage_account_id` - (Required) Storage account disk should belong to when a failover is done.

---

A `network_interface` block supports the following:

* `source_network_interface_id` - (Optional) (Required if the network_interface block is specified) Id source network interface.

* `target_static_ip` - (Optional) Static IP to assign when a failover is done.

* `target_subnet_name` - (Optional) Name of the subnet to to use when a failover is done.

* `recovery_public_ip_address_id` - (Optional) Id of the public IP object to use when a failover is done.

* `failover_test_static_ip` - (Optional) Static IP to assign when a test failover is done.

* `failover_test_subnet_name` - (Optional) Name of the subnet to to use when a test failover is done.

* `failover_test_public_ip_address_id` - (Optional) Id of the public IP object to use when a test failover is done.

---

The `target_disk_encryption` block supports:

* `disk_encryption_key` - (Required) A `disk_encryption_key` block as defined below.

* `key_encryption_key` - (Optional) A `key_encryption_key` block as defined below.

---

The `disk_encryption_key` block supports:

* `secret_url` - (Required) The URL to the Key Vault Secret used as the Disk Encryption Key that the Managed Disk will be associated with. This can be found as `id` on the `azurerm_key_vault_secret` resource. Changing this forces a new resource to be created.

* `vault_id` - (Required) The ID of the Key Vault. This can be found as `id` on the `azurerm_key_vault` resource. Changing this forces a new resource to be created.

---

The `key_encryption_key` block supports:

* `key_url` - (Required) The URL to the Key Vault Key used as the Key Encryption Key that the Managed Disk will be associated with. This can be found as `id` on the `azurerm_key_vault_key` resource. Changing this forces a new resource to be created.

* `vault_id` - (Required) The ID of the Key Vault. This can be found as `id` on the `azurerm_key_vault` resource. Changing this forces a new resource to be created.

## Attributes Reference

In addition to the arguments above, the following attributes are exported:

* `id` - The ID of the Site Recovery Replicated VM.

## Timeouts

The `timeouts` block allows you to specify [timeouts](https://www.terraform.io/language/resources/syntax#operation-timeouts) for certain actions:

* `create` - (Defaults to 3 hours) Used when creating the Site Recovery Replicated VM.
* `update` - (Defaults to 80 minutes) Used when updating the Site Recovery Replicated VM.
* `read` - (Defaults to 5 minutes) Used when retrieving the Site Recovery Replicated VM.
* `delete` - (Defaults to 80 minutes) Used when deleting the Site Recovery Replicated VM.

## Import

Site Recovery Replicated VM's can be imported using the `resource id`, e.g.

```shell
terraform import azurerm_site_recovery_replicated_vm.vmreplication /subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/resource-group-name/providers/Microsoft.RecoveryServices/vaults/recovery-vault-name/replicationFabrics/fabric-name/replicationProtectionContainers/protection-container-name/replicationProtectedItems/vm-replication-name
```

<!-- cache-key: cdktf-0.17.0-pre.15 input-96ba7e32717d33f841013571cb6e3f7873251e95385e37a60eed52caad72d92e -->