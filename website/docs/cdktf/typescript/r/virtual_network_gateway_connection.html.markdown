---
subcategory: "Network"
layout: "azurerm"
page_title: "Azure Resource Manager: azurerm_virtual_network_gateway_connection"
description: |-
  Manages a connection in an existing Virtual Network Gateway.
---


<!-- Please do not edit this file, it is generated. -->
# azurerm_virtual_network_gateway_connection

Manages a connection in an existing Virtual Network Gateway.

## Example Usage

### Site-to-Site connection

The following example shows a connection between an Azure virtual network
and an on-premises VPN device and network.

```typescript
import * as constructs from "constructs";
import * as cdktf from "cdktf";
/*Provider bindings are generated by running cdktf get.
See https://cdk.tf/provider-generation for more details.*/
import * as azurerm from "./.gen/providers/azurerm";
class MyConvertedCode extends cdktf.TerraformStack {
  constructor(scope: constructs.Construct, name: string) {
    super(scope, name);
    const azurermResourceGroupExample = new azurerm.resourceGroup.ResourceGroup(
      this,
      "example",
      {
        location: "West US",
        name: "test",
      }
    );
    const azurermVirtualNetworkExample =
      new azurerm.virtualNetwork.VirtualNetwork(this, "example_1", {
        addressSpace: ["10.0.0.0/16"],
        location: cdktf.Token.asString(azurermResourceGroupExample.location),
        name: "test",
        resourceGroupName: cdktf.Token.asString(
          azurermResourceGroupExample.name
        ),
      });
    /*This allows the Terraform resource name to match the original name. You can remove the call if you don't need them to match.*/
    azurermVirtualNetworkExample.overrideLogicalId("example");
    const azurermLocalNetworkGatewayOnpremise =
      new azurerm.localNetworkGateway.LocalNetworkGateway(this, "onpremise", {
        addressSpace: ["10.1.1.0/24"],
        gatewayAddress: "168.62.225.23",
        location: cdktf.Token.asString(azurermResourceGroupExample.location),
        name: "onpremise",
        resourceGroupName: cdktf.Token.asString(
          azurermResourceGroupExample.name
        ),
      });
    const azurermPublicIpExample = new azurerm.publicIp.PublicIp(
      this,
      "example_3",
      {
        allocationMethod: "Dynamic",
        location: cdktf.Token.asString(azurermResourceGroupExample.location),
        name: "test",
        resourceGroupName: cdktf.Token.asString(
          azurermResourceGroupExample.name
        ),
      }
    );
    /*This allows the Terraform resource name to match the original name. You can remove the call if you don't need them to match.*/
    azurermPublicIpExample.overrideLogicalId("example");
    const azurermSubnetExample = new azurerm.subnet.Subnet(this, "example_4", {
      addressPrefixes: ["10.0.1.0/24"],
      name: "GatewaySubnet",
      resourceGroupName: cdktf.Token.asString(azurermResourceGroupExample.name),
      virtualNetworkName: cdktf.Token.asString(
        azurermVirtualNetworkExample.name
      ),
    });
    /*This allows the Terraform resource name to match the original name. You can remove the call if you don't need them to match.*/
    azurermSubnetExample.overrideLogicalId("example");
    const azurermVirtualNetworkGatewayExample =
      new azurerm.virtualNetworkGateway.VirtualNetworkGateway(
        this,
        "example_5",
        {
          activeActive: false,
          enableBgp: false,
          ipConfiguration: [
            {
              privateIpAddressAllocation: "Dynamic",
              publicIpAddressId: cdktf.Token.asString(
                azurermPublicIpExample.id
              ),
              subnetId: cdktf.Token.asString(azurermSubnetExample.id),
            },
          ],
          location: cdktf.Token.asString(azurermResourceGroupExample.location),
          name: "test",
          resourceGroupName: cdktf.Token.asString(
            azurermResourceGroupExample.name
          ),
          sku: "Basic",
          type: "Vpn",
          vpnType: "RouteBased",
        }
      );
    /*This allows the Terraform resource name to match the original name. You can remove the call if you don't need them to match.*/
    azurermVirtualNetworkGatewayExample.overrideLogicalId("example");
    const azurermVirtualNetworkGatewayConnectionOnpremise =
      new azurerm.virtualNetworkGatewayConnection.VirtualNetworkGatewayConnection(
        this,
        "onpremise_6",
        {
          localNetworkGatewayId: cdktf.Token.asString(
            azurermLocalNetworkGatewayOnpremise.id
          ),
          location: cdktf.Token.asString(azurermResourceGroupExample.location),
          name: "onpremise",
          resourceGroupName: cdktf.Token.asString(
            azurermResourceGroupExample.name
          ),
          sharedKey: "4-v3ry-53cr37-1p53c-5h4r3d-k3y",
          type: "IPsec",
          virtualNetworkGatewayId: cdktf.Token.asString(
            azurermVirtualNetworkGatewayExample.id
          ),
        }
      );
    /*This allows the Terraform resource name to match the original name. You can remove the call if you don't need them to match.*/
    azurermVirtualNetworkGatewayConnectionOnpremise.overrideLogicalId(
      "onpremise"
    );
  }
}

```

### VNet-to-VNet connection

The following example shows a connection between two Azure virtual network
in different locations/regions.

```typescript
import * as constructs from "constructs";
import * as cdktf from "cdktf";
/*Provider bindings are generated by running cdktf get.
See https://cdk.tf/provider-generation for more details.*/
import * as azurerm from "./.gen/providers/azurerm";
class MyConvertedCode extends cdktf.TerraformStack {
  constructor(scope: constructs.Construct, name: string) {
    super(scope, name);
    const azurermResourceGroupEurope = new azurerm.resourceGroup.ResourceGroup(
      this,
      "europe",
      {
        location: "West Europe",
        name: "europe",
      }
    );
    const azurermResourceGroupUs = new azurerm.resourceGroup.ResourceGroup(
      this,
      "us",
      {
        location: "East US",
        name: "us",
      }
    );
    const azurermVirtualNetworkEurope =
      new azurerm.virtualNetwork.VirtualNetwork(this, "europe_2", {
        addressSpace: ["10.1.0.0/16"],
        location: cdktf.Token.asString(azurermResourceGroupEurope.location),
        name: "europe",
        resourceGroupName: cdktf.Token.asString(
          azurermResourceGroupEurope.name
        ),
      });
    /*This allows the Terraform resource name to match the original name. You can remove the call if you don't need them to match.*/
    azurermVirtualNetworkEurope.overrideLogicalId("europe");
    const azurermVirtualNetworkUs = new azurerm.virtualNetwork.VirtualNetwork(
      this,
      "us_3",
      {
        addressSpace: ["10.0.0.0/16"],
        location: cdktf.Token.asString(azurermResourceGroupUs.location),
        name: "us",
        resourceGroupName: cdktf.Token.asString(azurermResourceGroupUs.name),
      }
    );
    /*This allows the Terraform resource name to match the original name. You can remove the call if you don't need them to match.*/
    azurermVirtualNetworkUs.overrideLogicalId("us");
    const azurermPublicIpEurope = new azurerm.publicIp.PublicIp(
      this,
      "europe_4",
      {
        allocationMethod: "Dynamic",
        location: cdktf.Token.asString(azurermResourceGroupEurope.location),
        name: "europe",
        resourceGroupName: cdktf.Token.asString(
          azurermResourceGroupEurope.name
        ),
      }
    );
    /*This allows the Terraform resource name to match the original name. You can remove the call if you don't need them to match.*/
    azurermPublicIpEurope.overrideLogicalId("europe");
    const azurermPublicIpUs = new azurerm.publicIp.PublicIp(this, "us_5", {
      allocationMethod: "Dynamic",
      location: cdktf.Token.asString(azurermResourceGroupUs.location),
      name: "us",
      resourceGroupName: cdktf.Token.asString(azurermResourceGroupUs.name),
    });
    /*This allows the Terraform resource name to match the original name. You can remove the call if you don't need them to match.*/
    azurermPublicIpUs.overrideLogicalId("us");
    const azurermSubnetEuropeGateway = new azurerm.subnet.Subnet(
      this,
      "europe_gateway",
      {
        addressPrefixes: ["10.1.1.0/24"],
        name: "GatewaySubnet",
        resourceGroupName: cdktf.Token.asString(
          azurermResourceGroupEurope.name
        ),
        virtualNetworkName: cdktf.Token.asString(
          azurermVirtualNetworkEurope.name
        ),
      }
    );
    const azurermSubnetUsGateway = new azurerm.subnet.Subnet(
      this,
      "us_gateway",
      {
        addressPrefixes: ["10.0.1.0/24"],
        name: "GatewaySubnet",
        resourceGroupName: cdktf.Token.asString(azurermResourceGroupUs.name),
        virtualNetworkName: cdktf.Token.asString(azurermVirtualNetworkUs.name),
      }
    );
    const azurermVirtualNetworkGatewayEurope =
      new azurerm.virtualNetworkGateway.VirtualNetworkGateway(
        this,
        "europe_8",
        {
          ipConfiguration: [
            {
              privateIpAddressAllocation: "Dynamic",
              publicIpAddressId: cdktf.Token.asString(azurermPublicIpEurope.id),
              subnetId: cdktf.Token.asString(azurermSubnetEuropeGateway.id),
            },
          ],
          location: cdktf.Token.asString(azurermResourceGroupEurope.location),
          name: "europe-gateway",
          resourceGroupName: cdktf.Token.asString(
            azurermResourceGroupEurope.name
          ),
          sku: "Basic",
          type: "Vpn",
          vpnType: "RouteBased",
        }
      );
    /*This allows the Terraform resource name to match the original name. You can remove the call if you don't need them to match.*/
    azurermVirtualNetworkGatewayEurope.overrideLogicalId("europe");
    const azurermVirtualNetworkGatewayUs =
      new azurerm.virtualNetworkGateway.VirtualNetworkGateway(this, "us_9", {
        ipConfiguration: [
          {
            privateIpAddressAllocation: "Dynamic",
            publicIpAddressId: cdktf.Token.asString(azurermPublicIpUs.id),
            subnetId: cdktf.Token.asString(azurermSubnetUsGateway.id),
          },
        ],
        location: cdktf.Token.asString(azurermResourceGroupUs.location),
        name: "us-gateway",
        resourceGroupName: cdktf.Token.asString(azurermResourceGroupUs.name),
        sku: "Basic",
        type: "Vpn",
        vpnType: "RouteBased",
      });
    /*This allows the Terraform resource name to match the original name. You can remove the call if you don't need them to match.*/
    azurermVirtualNetworkGatewayUs.overrideLogicalId("us");
    new azurerm.virtualNetworkGatewayConnection.VirtualNetworkGatewayConnection(
      this,
      "europe_to_us",
      {
        location: cdktf.Token.asString(azurermResourceGroupEurope.location),
        name: "europe-to-us",
        peerVirtualNetworkGatewayId: cdktf.Token.asString(
          azurermVirtualNetworkGatewayUs.id
        ),
        resourceGroupName: cdktf.Token.asString(
          azurermResourceGroupEurope.name
        ),
        sharedKey: "4-v3ry-53cr37-1p53c-5h4r3d-k3y",
        type: "Vnet2Vnet",
        virtualNetworkGatewayId: cdktf.Token.asString(
          azurermVirtualNetworkGatewayEurope.id
        ),
      }
    );
    new azurerm.virtualNetworkGatewayConnection.VirtualNetworkGatewayConnection(
      this,
      "us_to_europe",
      {
        location: cdktf.Token.asString(azurermResourceGroupUs.location),
        name: "us-to-europe",
        peerVirtualNetworkGatewayId: cdktf.Token.asString(
          azurermVirtualNetworkGatewayEurope.id
        ),
        resourceGroupName: cdktf.Token.asString(azurermResourceGroupUs.name),
        sharedKey: "4-v3ry-53cr37-1p53c-5h4r3d-k3y",
        type: "Vnet2Vnet",
        virtualNetworkGatewayId: cdktf.Token.asString(
          azurermVirtualNetworkGatewayUs.id
        ),
      }
    );
  }
}

```

## Argument Reference

The following arguments are supported:

* `name` - (Required) The name of the connection. Changing the name forces a new resource to be created.

* `resourceGroupName` - (Required) The name of the resource group in which to create the connection Changing this forces a new resource to be created.

* `location` - (Required) The location/region where the connection is located. Changing this forces a new resource to be created.

* `type` - (Required) The type of connection. Valid options are `iPsec` (Site-to-Site), `expressRoute` (ExpressRoute), and `vnet2Vnet` (VNet-to-VNet). Each connection type requires different mandatory arguments (refer to the examples above). Changing this forces a new resource to be created.

* `virtualNetworkGatewayId` - (Required) The ID of the Virtual Network Gateway in which the connection will be created. Changing this forces a new resource to be created.

* `authorizationKey` - (Optional) The authorization key associated with the Express Route Circuit. This field is required only if the type is an ExpressRoute connection.

* `dpdTimeoutSeconds` - (Optional) The dead peer detection timeout of this connection in seconds. Changing this forces a new resource to be created.

* `expressRouteCircuitId` - (Optional) The ID of the Express Route Circuit when creating an ExpressRoute connection (i.e. when `type` is `expressRoute`). The Express Route Circuit can be in the same or in a different subscription. Changing this forces a new resource to be created.

* `peerVirtualNetworkGatewayId` - (Optional) The ID of the peer virtual network gateway when creating a VNet-to-VNet connection (i.e. when `type` is `vnet2Vnet`). The peer Virtual Network Gateway can be in the same or in a different subscription. Changing this forces a new resource to be created.

* `localAzureIpAddressEnabled` - (Optional) Use private local Azure IP for the connection. Changing this forces a new resource to be created.

* `localNetworkGatewayId` - (Optional) The ID of the local network gateway when creating Site-to-Site connection (i.e. when `type` is `iPsec`).

* `routingWeight` - (Optional) The routing weight. Defaults to `10`.

* `sharedKey` - (Optional) The shared IPSec key. A key could be provided if a Site-to-Site, VNet-to-VNet or ExpressRoute connection is created.

* `connectionMode` - (Optional) Connection mode to use. Possible values are `default`, `initiatorOnly` and `responderOnly`. Defaults to `default`. Changing this value will force a resource to be created.

* `connectionProtocol` - (Optional) The IKE protocol version to use. Possible values are `ikEv1` and `ikEv2`, values are `ikEv1` and `ikEv2`. Defaults to `ikEv2`. Changing this forces a new resource to be created.
-> **Note:** Only valid for `ipSec` connections on virtual network gateways with SKU `vpnGw1`, `vpnGw2`, `vpnGw3`, `vpnGw1Az`, `vpnGw2Az` or `vpnGw3Az`.

* `enableBgp` - (Optional) If `true`, BGP (Border Gateway Protocol) is enabled for this connection. Defaults to `false`.

* `customBgpAddresses` - (Optional) A `customBgpAddresses` (Border Gateway Protocol custom IP Addresses) block which is documented below.
    The block can only be used on `ipSec` / `activeactive` connections,
    For details about see [the relevant section in the Azure documentation](https://docs.microsoft.com/en-us/azure/vpn-gateway/vpn-gateway-howto-aws-bgp).

* `expressRouteGatewayBypass` - (Optional) If `true`, data packets will bypass ExpressRoute Gateway for data forwarding This is only valid for ExpressRoute connections.

* `egressNatRuleIds` - (Optional) A list of the egress NAT Rule Ids.

* `ingressNatRuleIds` - (Optional) A list of the ingress NAT Rule Ids.

* `usePolicyBasedTrafficSelectors` - (Optional) If `true`, policy-based traffic selectors are enabled for this connection. Enabling policy-based traffic selectors requires an `ipsecPolicy` block. Defaults to `false`.

* `ipsecPolicy` - (Optional) A `ipsecPolicy` block which is documented below.
    Only a single policy can be defined for a connection. For details on
    custom policies refer to [the relevant section in the Azure documentation](https://docs.microsoft.com/azure/vpn-gateway/vpn-gateway-ipsecikepolicy-rm-powershell).

* `trafficSelectorPolicy` - (Optional) One or more `trafficSelectorPolicy` blocks which are documented below.
    A `trafficSelectorPolicy` allows to specify a traffic selector policy proposal to be used in a virtual network gateway connection.
    For details about traffic selectors refer to [the relevant section in the Azure documentation](https://docs.microsoft.com/azure/vpn-gateway/vpn-gateway-connect-multiple-policybased-rm-ps).

* `tags` - (Optional) A mapping of tags to assign to the resource.

---

The `customBgpAddresses` block supports:

* `primary` - (Required) single IP address that is part of the `azurermVirtualNetworkGateway` ip_configuration (first one)
* `secondary` - (Required) single IP address that is part of the `azurermVirtualNetworkGateway` ip_configuration (second one)

---

The `ipsecPolicy` block supports:

* `dhGroup` - (Required) The DH group used in IKE phase 1 for initial SA. Valid options are `dhGroup1`, `dhGroup14`, `dhGroup2`, `dhGroup2048`, `dhGroup24`, `ecp256`, `ecp384`, or `none`.

* `ikeEncryption` - (Required) The IKE encryption algorithm. Valid options are `aes128`, `aes192`, `aes256`, `des`, `des3`, `gcmaes128`, or `gcmaes256`.

* `ikeIntegrity` - (Required) The IKE integrity algorithm. Valid options are `gcmaes128`, `gcmaes256`, `md5`, `sha1`, `sha256`, or `sha384`.

* `ipsecEncryption` - (Required) The IPSec encryption algorithm. Valid options are `aes128`, `aes192`, `aes256`, `des`, `des3`, `gcmaes128`, `gcmaes192`, `gcmaes256`, or `none`.

* `ipsecIntegrity` - (Required) The IPSec integrity algorithm. Valid options are `gcmaes128`, `gcmaes192`, `gcmaes256`, `md5`, `sha1`, or `sha256`.

* `pfsGroup` - (Required) The DH group used in IKE phase 2 for new child SA.
    Valid options are `ecp256`, `ecp384`, `pfs1`, `pfs14`, `pfs2`, `pfs2048`, `pfs24`, `pfsmm`,
    or `none`.

* `saDatasize` - (Optional) The IPSec SA payload size in KB. Must be at least `1024` KB. Defaults to `102400000` KB.

* `saLifetime` - (Optional) The IPSec SA lifetime in seconds. Must be at least `300` seconds. Defaults to `27000` seconds.

---

The `trafficSelectorPolicy` block supports:

* `localAddressCidrs` - (Required) List of local CIDRs.

* `remoteAddressCidrs` - (Required) List of remote CIDRs.

## Attributes Reference

In addition to the Arguments listed above - the following Attributes are exported:

* `id` - The ID of the Virtual Network Gateway Connection.

## Timeouts

The `timeouts` block allows you to specify [timeouts](https://www.terraform.io/language/resources/syntax#operation-timeouts) for certain actions:

* `create` - (Defaults to 30 minutes) Used when creating the Virtual Network Gateway Connection.
* `update` - (Defaults to 30 minutes) Used when updating the Virtual Network Gateway Connection.
* `read` - (Defaults to 5 minutes) Used when retrieving the Virtual Network Gateway Connection.
* `delete` - (Defaults to 30 minutes) Used when deleting the Virtual Network Gateway Connection.

## Import

Virtual Network Gateway Connections can be imported using their `resource id`, e.g.

```shell
terraform import azurerm_virtual_network_gateway_connection.exampleConnection /subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/myGroup1/providers/Microsoft.Network/connections/myConnection1
```

<!-- cache-key: cdktf-0.17.0-pre.15 input-770f4410d0392c7883de744ac0a5ccdb9ec3b58e4afcba7ebeac5e8d094716bb -->