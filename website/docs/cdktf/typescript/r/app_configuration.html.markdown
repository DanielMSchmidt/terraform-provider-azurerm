---
subcategory: "App Configuration"
layout: "azurerm"
page_title: "Azure Resource Manager: azurerm_app_configuration"
description: |-
  Manages an Azure App Configuration.

---


<!-- Please do not edit this file, it is generated. -->
# azurerm_app_configuration

Manages an Azure App Configuration.

## Disclaimers

-> **Note:** Version 3.27.0 and later of the Azure Provider include a Feature Toggle which will purge an App Configuration resource on destroy, rather than the default soft-delete. The Provider will automatically recover a soft-deleted App Configuration during creation if one is found. See [the Features block documentation](https://registry.terraform.io/providers/hashicorp/azurerm/latest/docs#features) for more information on Feature Toggles within Terraform.

-> **Note:** Reading and purging soft-deleted App Configurations requires the `microsoftAppConfiguration/locations/deletedConfigurationStores/read` and `microsoftAppConfiguration/locations/deletedConfigurationStores/purge/action` permission on Subscription scope. Recovering a soft-deleted App Configuration requires the `microsoftAppConfiguration/configurationStores/write` permission on Subscription or Resource Group scope. [More information can be found in the Azure Documentation for App Configuration](https://learn.microsoft.com/en-us/azure/azure-app-configuration/concept-soft-delete#permissions-to-recover-a-deleted-store). See the following links for more information on assigning [Azure custom roles](https://learn.microsoft.com/en-us/azure/role-based-access-control/custom-roles) or using the [`azurermRoleAssignment`](https://registry.terraform.io/providers/hashicorp/azurerm/latest/docs/resources/role_assignment) resource to assign a custom role.

## Example Usage

```typescript
import * as constructs from "constructs";
import * as cdktf from "cdktf";
/*Provider bindings are generated by running cdktf get.
See https://cdk.tf/provider-generation for more details.*/
import * as azurerm from "./.gen/providers/azurerm";
class MyConvertedCode extends cdktf.TerraformStack {
  constructor(scope: constructs.Construct, name: string) {
    super(scope, name);
    const azurermResourceGroupExample = new azurerm.resourceGroup.ResourceGroup(
      this,
      "example",
      {
        location: "West Europe",
        name: "example-resources",
      }
    );
    new azurerm.appConfiguration.AppConfiguration(this, "appconf", {
      location: cdktf.Token.asString(azurermResourceGroupExample.location),
      name: "appConf1",
      resourceGroupName: cdktf.Token.asString(azurermResourceGroupExample.name),
    });
  }
}

```

## Example Usage (encryption)

```typescript
import * as constructs from "constructs";
import * as cdktf from "cdktf";
/*Provider bindings are generated by running cdktf get.
See https://cdk.tf/provider-generation for more details.*/
import * as azurerm from "./.gen/providers/azurerm";
class MyConvertedCode extends cdktf.TerraformStack {
  constructor(scope: constructs.Construct, name: string) {
    super(scope, name);
    new azurerm.provider.AzurermProvider(this, "azurerm", {
      features: {
        appConfiguration: {
          purgeSoftDeleteOnDestroy: true,
          recoverSoftDeleted: true,
        },
      },
    });
    const azurermResourceGroupExample = new azurerm.resourceGroup.ResourceGroup(
      this,
      "example",
      {
        location: "West Europe",
        name: "example-resources",
      }
    );
    const azurermUserAssignedIdentityExample =
      new azurerm.userAssignedIdentity.UserAssignedIdentity(this, "example_2", {
        location: cdktf.Token.asString(azurermResourceGroupExample.location),
        name: "example-identity",
        resourceGroupName: cdktf.Token.asString(
          azurermResourceGroupExample.name
        ),
      });
    /*This allows the Terraform resource name to match the original name. You can remove the call if you don't need them to match.*/
    azurermUserAssignedIdentityExample.overrideLogicalId("example");
    const dataAzurermClientConfigCurrent =
      new azurerm.dataAzurermClientConfig.DataAzurermClientConfig(
        this,
        "current",
        {}
      );
    const azurermKeyVaultExample = new azurerm.keyVault.KeyVault(
      this,
      "example_4",
      {
        location: cdktf.Token.asString(azurermResourceGroupExample.location),
        name: "exampleKVt123",
        purgeProtectionEnabled: true,
        resourceGroupName: cdktf.Token.asString(
          azurermResourceGroupExample.name
        ),
        skuName: "standard",
        softDeleteRetentionDays: 7,
        tenantId: cdktf.Token.asString(dataAzurermClientConfigCurrent.tenantId),
      }
    );
    /*This allows the Terraform resource name to match the original name. You can remove the call if you don't need them to match.*/
    azurermKeyVaultExample.overrideLogicalId("example");
    const azurermKeyVaultAccessPolicyClient =
      new azurerm.keyVaultAccessPolicy.KeyVaultAccessPolicyA(this, "client", {
        keyPermissions: [
          "Get",
          "Create",
          "Delete",
          "List",
          "Restore",
          "Recover",
          "UnwrapKey",
          "WrapKey",
          "Purge",
          "Encrypt",
          "Decrypt",
          "Sign",
          "Verify",
          "GetRotationPolicy",
        ],
        keyVaultId: cdktf.Token.asString(azurermKeyVaultExample.id),
        objectId: cdktf.Token.asString(dataAzurermClientConfigCurrent.objectId),
        secretPermissions: ["Get"],
        tenantId: cdktf.Token.asString(dataAzurermClientConfigCurrent.tenantId),
      });
    const azurermKeyVaultAccessPolicyServer =
      new azurerm.keyVaultAccessPolicy.KeyVaultAccessPolicyA(this, "server", {
        keyPermissions: ["Get", "UnwrapKey", "WrapKey"],
        keyVaultId: cdktf.Token.asString(azurermKeyVaultExample.id),
        objectId: cdktf.Token.asString(
          azurermUserAssignedIdentityExample.principalId
        ),
        secretPermissions: ["Get"],
        tenantId: cdktf.Token.asString(dataAzurermClientConfigCurrent.tenantId),
      });
    const azurermKeyVaultKeyExample = new azurerm.keyVaultKey.KeyVaultKey(
      this,
      "example_7",
      {
        dependsOn: [
          azurermKeyVaultAccessPolicyClient,
          azurermKeyVaultAccessPolicyServer,
        ],
        keyOpts: [
          "decrypt",
          "encrypt",
          "sign",
          "unwrapKey",
          "verify",
          "wrapKey",
        ],
        keySize: 2048,
        keyType: "RSA",
        keyVaultId: cdktf.Token.asString(azurermKeyVaultExample.id),
        name: "exampleKVkey",
      }
    );
    /*This allows the Terraform resource name to match the original name. You can remove the call if you don't need them to match.*/
    azurermKeyVaultKeyExample.overrideLogicalId("example");
    const azurermAppConfigurationExample =
      new azurerm.appConfiguration.AppConfiguration(this, "example_8", {
        dependsOn: [
          azurermKeyVaultAccessPolicyClient,
          azurermKeyVaultAccessPolicyServer,
        ],
        encryption: {
          identityClientId: cdktf.Token.asString(
            azurermUserAssignedIdentityExample.clientId
          ),
          keyVaultKeyIdentifier: cdktf.Token.asString(
            azurermKeyVaultKeyExample.id
          ),
        },
        identity: {
          identityIds: [
            cdktf.Token.asString(azurermUserAssignedIdentityExample.id),
          ],
          type: "UserAssigned",
        },
        localAuthEnabled: true,
        location: cdktf.Token.asString(azurermResourceGroupExample.location),
        name: "appConf2",
        publicNetworkAccess: "Enabled",
        purgeProtectionEnabled: false,
        resourceGroupName: cdktf.Token.asString(
          azurermResourceGroupExample.name
        ),
        sku: "standard",
        softDeleteRetentionDays: 1,
        tags: {
          environment: "development",
        },
      });
    /*This allows the Terraform resource name to match the original name. You can remove the call if you don't need them to match.*/
    azurermAppConfigurationExample.overrideLogicalId("example");
  }
}

```

## Argument Reference

The following arguments are supported:

* `name` - (Required) Specifies the name of the App Configuration. Changing this forces a new resource to be created.

* `resourceGroupName` - (Required) The name of the resource group in which to create the App Configuration. Changing this forces a new resource to be created.

* `location` - (Required) Specifies the supported Azure location where the resource exists. Changing this forces a new resource to be created.

* `identity` - (Optional) An `identity` block as defined below.

~> **NOTE:** Azure does not allow a downgrade from `standard` to `free`.

* `encryption` - (Optional) An `encryption` block as defined below.

* `localAuthEnabled` - (Optional) Whether local authentication methods is enabled. Defaults to `true`.

* `publicNetworkAccess` - (Optional) The Public Network Access setting of the App Configuration. Possible values are `enabled` and `disabled`.

~> **NOTE:** If `publicNetworkAccess` is not specified, the App Configuration will be created as  `automatic`. However, once a different value is defined, can not be set again as automatic.

* `purgeProtectionEnabled` - (Optional) Whether Purge Protection is enabled. This field only works for `standard` sku. Defaults to `false`.

!> **Note:** Once Purge Protection has been enabled it's not possible to disable it. Deleting the App Configuration with Purge Protection enabled will schedule the App Configuration to be deleted (which will happen by Azure in the configured number of days).

* `sku` - (Optional) The SKU name of the App Configuration. Possible values are `free` and `standard`. Defaults to `free`.

* `softDeleteRetentionDays` - (Optional) The number of days that items should be retained for once soft-deleted. This field only works for `standard` sku. This value can be between `1` and `7` days. Defaults to `7`. Changing this forces a new resource to be created.

~> **Note:** If Purge Protection is enabled, this field can only be configured one time and cannot be updated.

* `tags` - (Optional) A mapping of tags to assign to the resource.

---

An `encryption` block supports the following:

* `keyVaultKeyIdentifier` - (Optional) Specifies the URI of the key vault key used to encrypt data.

* `identityClientId` - (Optional) Specifies the client id of the identity which will be used to access key vault.

---

An `identity` block supports the following:

* `type` - (Required) Specifies the type of Managed Service Identity that should be configured on this App Configuration. Possible values are `systemAssigned`, `userAssigned`, `SystemAssigned, UserAssigned` (to enable both).

* `identityIds` - (Optional) A list of User Assigned Managed Identity IDs to be assigned to this App Configuration.

~> **NOTE:** This is required when `type` is set to `userAssigned` or `SystemAssigned, UserAssigned`.

---

## Attributes Reference

In addition to the Arguments listed above - the following Attributes are exported:

* `id` - The App Configuration ID.

* `endpoint` - The URL of the App Configuration.

* `primaryReadKey` - A `primaryReadKey` block as defined below containing the primary read access key.

* `primaryWriteKey` - A `primaryWriteKey` block as defined below containing the primary write access key.

* `secondaryReadKey` - A `secondaryReadKey` block as defined below containing the secondary read access key.

* `secondaryWriteKey` - A `secondaryWriteKey` block as defined below containing the secondary write access key.

* `identity` - An `identity` block as defined below.

---

An `identity` block exports the following:

* `principalId` - The Principal ID associated with this Managed Service Identity.

* `tenantId` - The Tenant ID associated with this Managed Service Identity.

---

A `primaryReadKey` block exports the following:

* `connectionString` - The Connection String for this Access Key - comprising of the Endpoint, ID and Secret.

* `id` - The ID of the Access Key.

* `secret` - The Secret of the Access Key.

---

A `primaryWriteKey` block exports the following:

* `connectionString` - The Connection String for this Access Key - comprising of the Endpoint, ID and Secret.

* `id` - The ID of the Access Key.

* `secret` - The Secret of the Access Key.

---

A `secondaryReadKey` block exports the following:

* `connectionString` - The Connection String for this Access Key - comprising of the Endpoint, ID and Secret.

* `id` - The ID of the Access Key.

* `secret` - The Secret of the Access Key.

---

A `secondaryWriteKey` block exports the following:

* `connectionString` - The Connection String for this Access Key - comprising of the Endpoint, ID and Secret.

* `id` - The ID of the Access Key.

* `secret` - The Secret of the Access Key.

## Timeouts

The `timeouts` block allows you to specify [timeouts](https://www.terraform.io/language/resources/syntax#operation-timeouts) for certain actions:

* `create` - (Defaults to 30 minutes) Used when creating the App Configuration.
* `update` - (Defaults to 30 minutes) Used when updating the App Configuration.
* `read` - (Defaults to 5 minutes) Used when retrieving the App Configuration.
* `delete` - (Defaults to 30 minutes) Used when deleting the App Configuration.

## Import

App Configurations can be imported using the `resource id`, e.g.

```shell
terraform import azurerm_app_configuration.appconf /subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/resourceGroup1/providers/Microsoft.AppConfiguration/configurationStores/appConf1
```

<!-- cache-key: cdktf-0.17.0-pre.15 input-110d41eea9af7393e37410a403703e58eda65794d52a284c7c9fba2e1c2f8281 -->